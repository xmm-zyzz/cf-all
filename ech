import { connect } from 'cloudflare:sockets';

const authToken = 'e258977b-e413-4718-a3af-02d75492c349';
const fallbackAddress = 'all.ai9527.top';
const fallbackPort = '443';
const socks5Config = '';


const parsedSocks5Config = {};
const isSocksEnabled = false;

const enableECH = true;
const customDNS = 'https://dns.alidns.com/dns-query';
const customECHDomain = 'cloudflare-ech.com';
const remoteConfigUrl = 'https://raw.githubusercontent.com/byJoey/test/refs/heads/main/tist.ini';

const E_INVALID_DATA = atob('aW52YWxpZCBkYXRh');
const E_INVALID_USER = atob('aW52YWxpZCB1c2Vy');
const E_UNSUPPORTED_CMD = atob('Y29tbWFuZCBpcyBub3Qgc3VwcG9ydGVk');
const E_UDP_DNS_ONLY = atob('VURQIHByb3h5IG9ubHkgZW5hYmxlIGZvciBETlMgd2hpY2ggaXMgcG9ydCA1Mw==');
const E_INVALID_ADDR_TYPE = atob('aW52YWxpZCBhZGRyZXNzVHlwZQ==');
const E_EMPTY_ADDR = atob('YWRkcmVzc1ZhbHVlIGlzIGVtcHR5');
const E_WS_NOT_OPEN = atob('d2ViU29ja2V0LmVhZHlTdGF0ZSBpcyBub3Qgb3Blbg==');
const E_INVALID_ID_STR = atob('U3RyaW5naWZpZWQgaWRlbnRpZmllciBpcyBpbnZhbGlk');
const E_INVALID_SOCKS_ADDR = atob('SW52YWxpZCBTT0NLUyBhZGRyZXNzIGZvcm1hdA==');
const E_SOCKS_NO_METHOD = atob('bm8gYWNjZXB0YWJsZSBtZXRob2Rz');
const E_SOCKS_AUTH_NEEDED = atob('c29ja3Mgc2VydmVyIG5lZWRzIGF1dGg=');
const E_SOCKS_AUTH_FAIL = atob('ZmFpbCB0byBhdXRoIHNvY2tzIHNlcnZlcg==');
const E_SOCKS_CONN_FAIL = atob('ZmFpbCB0byBvcGVuIHNvY2tzIGNvbm5lY3Rpb24=');

const ADDRESS_TYPE_IPV4 = 1;
const ADDRESS_TYPE_URL = 2;
const ADDRESS_TYPE_IPV6 = 3;

export default {
	async fetch(request, env, ctx) {
		try {
			const subPath = authToken;
			const url = new URL(request.url);

			if (request.headers.get('Upgrade') === 'websocket') {
				return await handleWsRequest(request);
			} else if (request.method === 'GET') {
				if (url.pathname === '/') {
					const successHtml = `<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>可以了</title><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;margin:0;background-color:#121212;color:#e0e0e0;text-align:center;}.container{padding:2rem;border-radius:8px;background-color:#1e1e1e;box-shadow:0 4px 6px rgba(0,0,0,0.1);}h1{color:#4caf50;}</style></head><body><div class="container"><h1>可以了</h1><p>www.x-aniu.com</p></div></body></html>`;
					return new Response(successHtml, { status: 200, headers: { 'Content-Type': 'text/html; charset=utf-8' } });
				}
				if (url.pathname.toLowerCase().includes(`/${subPath}`)) {
					return await handleSubscriptionRequest(request, authToken);
				}
			}
			return new Response('Not Found', { status: 404 });
		} catch (err) {
			return new Response(err.toString(), { status: 500 });
		}
	},
};

async function handleSubscriptionRequest(request, uuid) {
    const url = new URL(request.url);
    const finalLinks = [];
    const workerDomain = url.hostname;
    const newIPList = await fetchAndParseNewIPs();
    if (newIPList.length > 0) {
        finalLinks.push(...generateLinksFromNewIPs(newIPList, uuid, workerDomain));
    }

    const target = url.searchParams.get('target') || 'base64';

    if (target.toLowerCase() === 'clash' || target.toLowerCase() === 'clashr') {
        if (finalLinks.length === 0) {
            return new Response('# Empty Config', { status: 200, headers: { 'Content-Type': 'text/yaml; charset=utf-8' } });
        }
        const clashConfig = await generateClashConfig(finalLinks);
        return new Response(clashConfig, { headers: { 'Content-Type': 'text/yaml; charset=utf-8' } });
    } else {
        if (finalLinks.length === 0) {
            const errorLink = `vless://00000000-0000-0000-0000-000000000000@127.0.0.1:80?encryption=none&security=none&type=ws&host=error.com&path=%2F#${encodeURIComponent(errorRemark)}`;
            finalLinks.push(errorLink);
        }
        const subscriptionContent = btoa(finalLinks.join('\n'));

        return new Response(subscriptionContent, {
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                'X-ECH-Status': enableECH ? 'ENABLED' : 'DISABLED',
                'X-ECH-Config-Length': enableECH ? `${customECHDomain}+${customDNS}`.length : '0'
            },
        });
    }
}

async function fetchAndParseNewIPs() {
    const url = "https://ccq.xmma.top/heads/main/transformed_result.csv?token=CCQ";
    let results = [];
    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.error(`[GitHub Source] Failed to fetch new IPs, status: ${response.status}`);
            return [];
        }
        const text = await response.text();
        const lines = text.trim().replace(/\r/g, "").split('\n');
        const regex = /^([^:]+):(\d+)#(.*)$/;

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            const match = trimmedLine.match(regex);
            if (match) {
                results.push({
                    ip: match[1],
                    port: parseInt(match[2], 10),
                    name: match[3].trim() || match[1]
                });
            } else {
                console.warn(`[GitHub Source] Line did not match format: "${trimmedLine}"`);
            }
        }
        console.log(`[GitHub Source] Successfully parsed ${results.length} IPs.`);
        return results;
    } catch (error) {
        console.error("[GitHub Source] Error fetching or parsing new IPs:", error);
        return [];
    }
}

function generateLinksFromNewIPs(list, uuid, workerDomain) {
    const links = [];
    const wsPath = '/?ed=2048';
    const proto = 'vless';

    list.forEach(item => {
        const nodeName = item.name;
        const safeIP = item.ip.includes(':') ? `[${item.ip}]` : item.ip;

        const params = {
            encryption: 'none',
            security: 'tls',
            sni: workerDomain,
            fp: 'chrome',
            type: 'ws',
            host: workerDomain,
            path: wsPath
        };

        if (enableECH) {
            params.ech = `${customECHDomain}+${customDNS}`;
            params.alpn = 'h3,h2,http/1.1';
        }

        const wsParams = new URLSearchParams(params);
        links.push(`${proto}://${uuid}@${safeIP}:${item.port}?${wsParams.toString()}#${encodeURIComponent(nodeName)}`);
    });
    return links;
}

function parseLinkToClashNode(link) {
    try {
        const url = new URL(link);
        const params = url.searchParams;

        return {
            name: url.hash ? decodeURIComponent(url.hash.substring(1)) : url.hostname,
            type: 'vless',
            server: url.hostname,
            port: parseInt(url.port),
            uuid: url.username,
            tls: params.get('security') === 'tls',
            udp: false,
            sni: params.get('sni'),
            network: params.get('type'),
            'client-fingerprint': params.get('fp') || 'chrome',
            'ws-opts': {
                path: params.get('path'),
                headers: {
                    Host: params.get('host')
                }
            },
            ...(params.get('ech') ? {
                ech: params.get('ech')
            } : {})
        };
    } catch (e) {
        return null;
    }
}
async function generateClashConfig(links) {
    let configContent = "";

    try {
        const remoteResp = await fetch(remoteConfigUrl);
        if (remoteResp.ok) {
            configContent = await remoteResp.text();
        }
    } catch (e) {
        console.log("Fetch remote config failed, using minimal template");
    }

    const proxies = [];
    const proxySet = new Set();

    links.forEach(link => {
        const node = parseLinkToClashNode(link);
        if (node) {
            let name = node.name;
            let counter = 1;
            while (proxySet.has(name)) {
                name = `${node.name} ${counter}`;
                counter++;
            }
            proxySet.add(name);
            node.name = name;
            proxies.push(node);
        }
    });

    // Clash Proxies 段
    let yamlProxies = "";
    proxies.forEach(node => {
        let nodeConfig = `  - name: ${node.name}\n`;
        nodeConfig += `    type: ${node.type}\n`;
        nodeConfig += `    server: ${node.server}\n`;
        nodeConfig += `    port: ${node.port}\n`;
        nodeConfig += `    uuid: ${node.uuid}\n`;
        nodeConfig += `    tls: ${node.tls}\n`;
        nodeConfig += `    sni: ${node.sni}\n`;
        nodeConfig += `    network: ${node.network}\n`;
        nodeConfig += `    udp: ${node.udp}\n`;

        if (node['client-fingerprint']) {
            nodeConfig += `    client-fingerprint: ${node['client-fingerprint']}\n`;
        }

        if (node['ws-opts']) {
            nodeConfig += `    ws-opts:\n`;
            nodeConfig += `      path: ${node['ws-opts'].path}\n`;
            nodeConfig += `      headers:\n`;
            nodeConfig += `        Host: ${node['ws-opts'].headers.Host}\n`;
        }

        if (node['ech']) {
            nodeConfig += `    ech: "${node['ech']}"\n`;
        }

        yamlProxies += nodeConfig;
    });

    if (configContent.includes('proxies:')) {
        const lines = configContent.split('\n');
        let newConfig = [];
        let inProxies = false;
        let proxiesReplaced = false;
        let foundNextKey = false;

        for (let line of lines) {
            if (!proxiesReplaced && line.trim().startsWith('proxies:')) {
                inProxies = true;
                newConfig.push(line);
                newConfig.push(yamlProxies);
                proxiesReplaced = true;
            } else if (inProxies) {
                if (line.trim() === '' || line.startsWith('  ') || line.startsWith('\t')) {
                    continue;
                } else {
                    inProxies = false;
                    foundNextKey = true;
                }
            }

            if (!inProxies && !proxiesReplaced) {
                newConfig.push(line);
            } else if (foundNextKey) {
                newConfig.push(line);
            }
        }
        return newConfig.join('\n');
    } else {
        if (!configContent.includes('port:')) {
            configContent = `port: 7890\nsocks-port: 7891\nallow-lan: true\nmode: rule\nlog-level: info\n` + configContent;
        }
        return configContent + '\nproxies:\n' + yamlProxies;
    }
}

async function handleWsRequest(request) {
    const wsPair = new WebSocketPair();
    const [clientSock, serverSock] = Object.values(wsPair);
    serverSock.accept();

    let remoteConnWrapper = { socket: null };
    let isDnsQuery = false;

    const earlyData = request.headers.get('sec-websocket-protocol') || '';
    const readable = makeReadableStream(serverSock, earlyData);

    readable.pipeTo(new WritableStream({
        async write(chunk) {
            if (isDnsQuery) return await forwardUDP(chunk, serverSock, null);
            if (remoteConnWrapper.socket) {
                const writer = remoteConnWrapper.socket.writable.getWriter();
                await writer.write(chunk);
                writer.releaseLock();
                return;
            }
            const { hasError, message, addressType, port, hostname, rawIndex, version, isUDP } = parseWsPacketHeader(chunk, authToken);
            if (hasError) throw new Error(message);

            if (isUDP) {
                if (port === 53) isDnsQuery = true;
                else throw new Error(E_UDP_DNS_ONLY);
            }
            const respHeader = new Uint8Array([version[0], 0]);
            const rawData = chunk.slice(rawIndex);

            if (isDnsQuery) return forwardUDP(rawData, serverSock, respHeader);

            await forwardTCP(addressType, hostname, port, rawData, serverSock, respHeader, remoteConnWrapper);
        },
    })).catch((err) => { console.log('WS Stream Error:', err); });

    return new Response(null, { status: 101, webSocket: clientSock });
}

async function forwardTCP(addrType, host, portNum, rawData, ws, respHeader, remoteConnWrapper) {
    async function connectAndSend(address, port) {
        const remoteSock = isSocksEnabled ?
            await establishSocksConnection(addrType, address, port) :
            connect({ hostname: address, port: port });
        const writer = remoteSock.writable.getWriter();
        await writer.write(rawData);
        writer.releaseLock();
        return remoteSock;
    }
    async function retryConnection() {
        const newSocket = isSocksEnabled ?
            await connectAndSend(host, portNum) :
            await connectAndSend(fallbackAddress || host, parseInt(fallbackPort, 10) || portNum);
        remoteConnWrapper.socket = newSocket;
        newSocket.closed.catch(() => {}).finally(() => closeSocketQuietly(ws));
        connectStreams(newSocket, ws, respHeader, null);
    }
    try {
        const initialSocket = await connectAndSend(host, portNum);
        remoteConnWrapper.socket = initialSocket;
        connectStreams(initialSocket, ws, respHeader, retryConnection);
    } catch (err) {
        console.log('Initial connection failed, trying fallback:', err);
        retryConnection();
    }
}

function parseWsPacketHeader(chunk, token) {
	if (chunk.byteLength < 24) return { hasError: true, message: E_INVALID_DATA };
	const version = new Uint8Array(chunk.slice(0, 1));
	if (formatIdentifier(new Uint8Array(chunk.slice(1, 17))) !== token) return { hasError: true, message: E_INVALID_USER };
	const optLen = new Uint8Array(chunk.slice(17, 18))[0];
	const cmd = new Uint8Array(chunk.slice(18 + optLen, 19 + optLen))[0];
	let isUDP = false;
	if (cmd === 1) {} else if (cmd === 2) { isUDP = true; } else { return { hasError: true, message: E_UNSUPPORTED_CMD }; }
	const portIdx = 19 + optLen;
	const port = new DataView(chunk.slice(portIdx, portIdx + 2)).getUint16(0);
	let addrIdx = portIdx + 2, addrLen = 0, addrValIdx = addrIdx + 1, hostname = '';
	const addressType = new Uint8Array(chunk.slice(addrIdx, addrValIdx))[0];
	switch (addressType) {
		case ADDRESS_TYPE_IPV4: addrLen = 4; hostname = new Uint8Array(chunk.slice(addrValIdx, addrValIdx + addrLen)).join('.'); break;
		case ADDRESS_TYPE_URL: addrLen = new Uint8Array(chunk.slice(addrValIdx, addrValIdx + 1))[0]; addrValIdx += 1; hostname = new TextDecoder().decode(chunk.slice(addrValIdx, addrValIdx + addrLen)); break;
		case ADDRESS_TYPE_IPV6: addrLen = 16; const ipv6 = []; const ipv6View = new DataView(chunk.slice(addrValIdx, addrValIdx + addrLen)); for (let i = 0; i < 8; i++) ipv6.push(ipv6View.getUint16(i * 2).toString(16)); hostname = ipv6.join(':'); break;
		default: return { hasError: true, message: `${E_INVALID_ADDR_TYPE}: ${addressType}` };
	}
	if (!hostname) return { hasError: true, message: `${E_EMPTY_ADDR}: ${addressType}` };
	return { hasError: false, addressType, port, hostname, isUDP, rawIndex: addrValIdx + addrLen, version };
}

function makeReadableStream(socket, earlyDataHeader) {
	let cancelled = false;
	return new ReadableStream({
		start(controller) {
			socket.addEventListener('message', (event) => { if (!cancelled) controller.enqueue(event.data); });
			socket.addEventListener('close', () => { if (!cancelled) { closeSocketQuietly(socket); controller.close(); } });
			socket.addEventListener('error', (err) => controller.error(err));
			const { earlyData, error } = base64ToArray(earlyDataHeader);
			if (error) controller.error(error); else if (earlyData) controller.enqueue(earlyData);
		},
		cancel() { cancelled = true; closeSocketQuietly(socket); }
	});
}

async function connectStreams(remoteSocket, webSocket, headerData, retryFunc) {
	let header = headerData, hasData = false;
	await remoteSocket.readable.pipeTo(
		new WritableStream({
			async write(chunk, controller) {
				hasData = true;
				if (webSocket.readyState !== 1) controller.error(E_WS_NOT_OPEN);
				if (header) { webSocket.send(await new Blob([header, chunk]).arrayBuffer()); header = null; }
                else { webSocket.send(chunk); }
			},
			abort(reason) { console.error("Readable aborted:", reason); },
		})
	).catch((error) => { console.error("Stream connection error:", error); closeSocketQuietly(webSocket); });
	if (!hasData && retryFunc) retryFunc();
}

async function forwardUDP(udpChunk, webSocket, respHeader) {
	try {
		const tcpSocket = connect({ hostname: '8.8.4.4', port: 53 });
		let vlessHeader = respHeader;
		const writer = tcpSocket.writable.getWriter();
		await writer.write(udpChunk);
		writer.releaseLock();
		await tcpSocket.readable.pipeTo(new WritableStream({
			async write(chunk) {
				if (webSocket.readyState === 1) {
					if (vlessHeader) { webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer()); vlessHeader = null; }
                    else { webSocket.send(chunk); }
				}
			},
		}));
	} catch (error) { console.error(`DNS forward error: ${error.message}`); }
}

async function establishSocksConnection(addrType, address, port) {
	const { username, password, hostname, socksPort } = parsedSocks5Config;
	const socket = connect({ hostname: port: socksPort });
	const writer = socket.writable.getWriter();
	await writer.write(new Uint8Array(username ? [5, 2, 0, 2] : [5, 1, 0]));
	const reader = socket.readable.getReader();
	let res = (await reader.read()).value;
	if (res[0] !== 5 || res[1] === 255) throw new Error(E_SOCKS_NO_METHOD);
	if (res[1] === 2) {
		if (!username || !password) throw new Error(E_SOCKS_AUTH_NEEDED);
		const encoder = new TextEncoder();
		const authRequest = new Uint8Array([1, username.length, ...encoder.encode(username), password.length, ...encoder.encode(password)]);
		await writer.write(authRequest);
		res = (await reader.read()).value;
		if (res[0] !== 1 || res[1] !== 0) throw new Error(E_SOCKS_AUTH_FAIL);
	}
	const encoder = new TextEncoder(); let DSTADDR;
	switch (addrType) {
		case ADDRESS_TYPE_IPV4: DSTADDR = new Uint8Array([1, ...address.split('.').map(Number)]); break;
		case ADDRESS_TYPE_URL: DSTADDR = new Uint8Array([3, address.length, ...encoder.encode(address)]); break;
		case ADDRESS_TYPE_IPV6: DSTADDR = new Uint8Array([4, ...address.split(':').flatMap(x => [parseInt(x.slice(0, 2), 16), parseInt(x.slice(2), 16)])]); break;
		default: throw new Error(E_INVALID_ADDR_TYPE);
	}
	await writer.write(new Uint8Array([5, 1, 0, ...DSTADDR, port >> 8, port & 255]));
	res = (await reader.read()).value;
	if (res[1] !== 0) throw new Error(E_SOCKS_CONN_FAIL);
	writer.releaseLock(); reader.releaseLock();
	return socket;
}

function parseSocksConfig(address) {
    let [latter, former] = address.split("@").reverse(); let username, password, hostname, socksPort;
    if (former) { const formers = former.split(":"); if (formers.length !== 2) throw new Error(E_INVALID_SOCKS_ADDR);[username, password] = formers; }
    const latters = latter.split(":"); socksPort = Number(latters.pop()); if (isNaN(socksPort)) throw new Error(E_INVALID_SOCKS_ADDR);
    hostname = latters.join(":"); if (hostname.includes(":") && !/^\[.*\]$/.test(hostname)) throw new Error(E_INVALID_SOCKS_ADDR);
    return { username, password, hostname, socksPort };
}

function base64ToArray(b64Str) {
    if (!b64Str) return { error: null };
    try { b64Str = b64Str.replace(/-/g, '+').replace(/_/g, '/'); return { earlyData: Uint8Array.from(atob(b64Str), (c) => c.charCodeAt(0)).buffer, error: null }; }
    catch (error) { return { error }; }
}

function isValidFormat(uuid) { return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid); }

function closeSocketQuietly(socket) { try { if (socket.readyState === 1 || socket.readyState === 2) socket.close(); } catch (error) {} }

const hexTable = Array.from({ length: 256 }, (v, i) => (i + 256).toString(16).slice(1));

function formatIdentifier(arr, offset = 0) {
    const id = (hexTable[arr[offset]]+hexTable[arr[offset+1]]+hexTable[arr[offset+2]]+hexTable[arr[offset+3]]+"-"+hexTable[arr[offset+4]]+hexTable[arr[offset+5]]+"-"+hexTable[arr[offset+6]]+hexTable[arr[offset+7]]+"-"+hexTable[arr[offset+8]]+hexTable[arr[offset+9]]+"-"+hexTable[arr[offset+10]]+hexTable[arr[offset+11]]+hexTable[arr[offset+12]]+hexTable[arr[offset+13]]+hexTable[arr[offset+14]]+hexTable[arr[offset+15]]).toLowerCase();
    if (!isValidFormat(id)) throw new TypeError(E_INVALID_ID_STR);
    return id;
}
async function fetchECHConfig(domain) {
    if (!enableECH) {
        return null;
    }
    
    const targetDomain = domain || customECHDomain;
    
    try {
        const googleDoHUrl = `https://dns.google/dns-query?name=${targetDomain}&type=65`;
        const response = await fetch(googleDoHUrl, {
            headers: {
                'Accept': 'application/dns-json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (data.Answer && data.Answer.length > 0) {
                for (const answer of data.Answer) {
                    if (answer.data && typeof answer.data === 'string') {
                        const match = answer.data.match(/ech=([^"'\s]+)/);
                        if (match) {
                            return match[1];
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.log("[fetchECHConfig] Google DoH failed:", error);
    }
    
    return null;
}
