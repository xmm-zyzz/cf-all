import { connect } from "cloudflare:sockets";

const UUID = "e258977b-e413-4718-a3af-02d75492c349";

const FALLBACK_HOST = "jp.x9527.xyz";
const FALLBACK_PORT = 443;

const WS_PATH = encodeURIComponent("/?ed=2095");

const ENABLE_ECH = true;

const CSV_URL = "https://ccq-4bs.pages.dev/heads/main/hebing.csv?token=CCQ";

const ECH_NAME = "cloudflare-ech.com";
const ECH_SNI = "cloudflare-ech.com";

const ECH_REFRESH_MS = 6 * 60 * 60 * 1000;

let ECH_CACHE = { value: null, expiresAt: 0, inFlight: null };


const AT_IPV4 = 1;
const AT_DOMAIN = 2;
const AT_IPV6 = 3;

const te = new TextEncoder();
const td = new TextDecoder();

export default {
  async fetch(request, env) {
    try {
      const url = new URL(request.url);

      if (request.headers.get("Upgrade") === "websocket") {
        return handleWsRequest(request);
      }

      if (request.method === "GET") {
        if (url.pathname === "/") {
          return new Response(
            "<!doctype html><meta charset=utf-8><title>OK</title><h1>可以了</h1><p>www.x-aniu.com</p>",
            { headers: { "content-type": "text/html; charset=utf-8" } }
          );
        }

        if (url.pathname === `/${UUID}`) {
          return handleSubscriptionRequest(request);
        }
      }

      return new Response("Not Found", { status: 404 });
    } catch (e) {
      return new Response(String(e?.message || e), { status: 500 });
    }
  },
};

async function handleSubscriptionRequest(request) {
  const url = new URL(request.url);
  const host = url.hostname;

  const ech = ENABLE_ECH ? await getECH() : null;

  const nodes = await fetchCsvNodes(CSV_URL);
  const links = nodes.length
    ? nodes.map((n) => buildVlessLink(UUID, n.ip, n.port, n.name, host, ech))
    : [
        `vless://00000000-0000-0000-0000-000000000000@127.0.0.1:80?encryption=none&security=none&type=ws&host=error.com&path=%2F#${encodeURIComponent(
          "NO-NODES"
        )}`,
      ];

  return new Response(btoa(links.join("\n")), {
    headers: {
      "content-type": "text/plain; charset=utf-8",
      "cache-control": "no-store",
    },
  });
}

function buildVlessLink(uuid, ip, port, name, workerHost, ech) {
  const safeIP = ip.includes(":") ? `[${ip}]` : ip;
  const label = encodeURIComponent(name || `${ip}:${port}`);

  // 启用 ECH 时，用 cloudflare-ech.com 做 SNI（ECHConfig 也来自它）
  const sni = ech ? ECH_SNI : workerHost;

  const p = new URLSearchParams({
    encryption: "none",
    security: "tls",
    sni,
    fp: ech ? "chrome" : "randomized",
    type: "ws",
    host: workerHost,     // 仍然用你的 Worker 域名做 HTTP Host，保证路由正确
    path: WS_PATH,
  });

  if (ech) {
    p.set("alpn", "h3,h2,http/1.1");
    p.set("ech", ech);
  }

  return `vless://${uuid}@${safeIP}:${port}?${p.toString()}#${label}`;
}


async function fetchCsvNodes(csvUrl) {
  try {
    const r = await fetch(csvUrl, { signal: AbortSignal.timeout(8000) });
    if (!r.ok) return [];
    const text = (await r.text()).trim().replace(/\r/g, "");
    if (!text) return [];

    // 格式: ip:port#name
    const out = [];
    for (const line of text.split("\n")) {
      const s = line.trim();
      if (!s) continue;
      const m = s.match(/^([^:]+):(\d+)\s*#\s*(.*)$/);
      if (!m) continue;
      out.push({ ip: m[1], port: Number(m[2]), name: (m[3] || m[1]).trim() });
    }
    return out;
  } catch {
    return [];
  }
}

async function getECH() {
  const now = Date.now();
  if (ECH_CACHE.value && now < ECH_CACHE.expiresAt) return ECH_CACHE.value;
  if (ECH_CACHE.inFlight) return ECH_CACHE.inFlight;

  ECH_CACHE.inFlight = (async () => {
    const { ech, ttlSec } = await fetchECHNoStale();

    // 如果 DNS 回了 TTL，就用 TTL 的 80% 作为过期时间，但上限不超过 ECH_REFRESH_MS
    // 没 TTL 就按 ECH_REFRESH_MS
    const ttlMsFromDns =
      typeof ttlSec === "number" && ttlSec > 0 ? Math.floor(ttlSec * 1000 * 0.8) : 0;

    const ttlMs = Math.max(
      5 * 60 * 1000, // 最少 5 分钟，避免抖动
      Math.min(ECH_REFRESH_MS, ttlMsFromDns || ECH_REFRESH_MS)
    );

    ECH_CACHE.value = ech || null;
    ECH_CACHE.expiresAt = Date.now() + ttlMs;
    return ECH_CACHE.value;
  })().finally(() => {
    ECH_CACHE.inFlight = null;
  });

  return ECH_CACHE.inFlight;
}

// 强制不走缓存：cache=no-cache + cf.cacheTtl=0 + URL 加时间戳
async function fetchECHNoStale() {
  const qs = `name=${encodeURIComponent(ECH_NAME)}&type=65&_=${Date.now()}`;

  const tries = [
    [`https://cloudflare-dns.com/dns-query?${qs}`, "application/dns-json"],
    [`https://dns.google/resolve?${qs}`, "application/json"],
  ];

  for (const [u, accept] of tries) {
    try {
      const r = await fetch(u, {
        headers: {
          Accept: accept,
          "Cache-Control": "no-cache",
          Pragma: "no-cache",
        },
        // Workers fetch 仅支持 no-cache/no-store；no-cache 会强制重新验证 :contentReference[oaicite:1]{index=1}
        cache: "no-cache",
        // cf.cacheTtl=0 表示边缘缓存立即过期 :contentReference[oaicite:2]{index=2}
        cf: { cacheTtl: 0, cacheEverything: false },
        signal: AbortSignal.timeout(5000),
      });

      if (!r.ok) continue;
      const j = await r.json();
      const ans = Array.isArray(j?.Answer) ? j.Answer : [];

      let minTtl = null;

      for (const a of ans) {
        const data = String(a?.data || "");
        const ech = extractECH(data);
        if (!ech) continue;

        const t = Number(a?.TTL);
        if (!Number.isNaN(t) && t > 0) minTtl = minTtl == null ? t : Math.min(minTtl, t);

        return { ech, ttlSec: minTtl };
      }
    } catch {}
  }

  return { ech: null, ttlSec: null };
}

function extractECH(data) {
  // 兼容：ech=xxx / ech="xxx"
  let m = data.match(/ech="?([^"\s]+)"?/i);
  if (m?.[1]) return m[1];

  // 有些实现会把 data 做 base64/base64url，尝试解一下再提取
  const decoded =
    tryAtob(data) || tryAtob(data.replace(/-/g, "+").replace(/_/g, "/"));
  if (decoded) {
    m = decoded.match(/ech="?([^"\s]+)"?/i);
    if (m?.[1]) return m[1];
  }
  return null;
}

function tryAtob(s) {
  try {
    return atob(s);
  } catch {
    return null;
  }
}


async function handleWsRequest(request) {
  const pair = new WebSocketPair();
  const [client, server] = Object.values(pair);
  server.accept();

  let remote = null;
  let isDns = false;

  const early = request.headers.get("sec-websocket-protocol") || "";
  const readable = makeReadableStream(server, early);

  readable
    .pipeTo(
      new WritableStream({
        async write(chunk) {
          if (isDns) return forwardDns(chunk, server, null);

          if (remote) {
            const w = remote.writable.getWriter();
            await w.write(chunk);
            w.releaseLock();
            return;
          }

          const h = parseHeader(chunk, UUID);
          if (h.err) throw new Error(h.err);

          if (h.isUDP) {
            if (h.port !== 53) throw new Error("UDP only for DNS(53)");
            isDns = true;
            return forwardDns(chunk.slice(h.dataIndex), server, new Uint8Array([h.ver, 0]));
          }

          const respHeader = new Uint8Array([h.ver, 0]);
          const raw = chunk.slice(h.dataIndex);

          await forwardTcp(h.host, h.port, raw, server, respHeader, (sock) => (remote = sock));
        },
      })
    )
    .catch(() => closeQuiet(server));

  return new Response(null, { status: 101, webSocket: client });
}

async function forwardTcp(host, port, firstData, ws, respHeader, setRemote) {
  const connectOnce = async (h, p) => {
    const s = connect({ hostname: h, port: p });
    const w = s.writable.getWriter();
    await w.write(firstData);
    w.releaseLock();
    return s;
  };

  const connectWithFallback = async () => {
    const s = await connectOnce(FALLBACK_HOST || host, FALLBACK_PORT || port);
    setRemote(s);
    s.closed.catch(() => {}).finally(() => closeQuiet(ws));
    pipeRemoteToWs(s, ws, respHeader);
  };

  try {
    const s = await connectOnce(host, port);
    setRemote(s);
    pipeRemoteToWs(s, ws, respHeader, connectWithFallback);
  } catch {
    await connectWithFallback();
  }
}

function pipeRemoteToWs(remote, ws, header, retry) {
  let hasData = false;
  remote.readable
    .pipeTo(
      new WritableStream({
        async write(chunk, controller) {
          hasData = true;
          if (ws.readyState !== 1) return controller.error("ws not open");

          if (header) {
            ws.send(concatU8(header, chunk));
            header = null;
          } else {
            ws.send(chunk);
          }
        },
      })
    )
    .catch(() => closeQuiet(ws))
    .finally(() => {
      if (!hasData && retry) retry();
    });
}

async function forwardDns(udpData, ws, header) {
  try {
    const s = connect({ hostname: "8.8.4.4", port: 53 });
    let h = header;

    const w = s.writable.getWriter();
    await w.write(udpData);
    w.releaseLock();

    await s.readable.pipeTo(
      new WritableStream({
        async write(chunk) {
          if (ws.readyState !== 1) return;
          if (h) {
            ws.send(concatU8(h, chunk));
            h = null;
          } else {
            ws.send(chunk);
          }
        },
      })
    );
  } catch {}
}

function parseHeader(buf, uuid) {
  if (buf.byteLength < 24) return { err: "invalid data" };

  const u8 = new Uint8Array(buf);
  const ver = u8[0];

  // UUID: bytes[1..16]
  if (bytesToUuid(u8, 1) !== uuid) return { err: "invalid user" };

  const optLen = u8[17];
  const cmd = u8[18 + optLen];
  const isUDP = cmd === 2;
  if (cmd !== 1 && cmd !== 2) return { err: "unsupported cmd" };

  const portIndex = 19 + optLen;
  const port = (u8[portIndex] << 8) | u8[portIndex + 1];

  let idx = portIndex + 2;
  const at = u8[idx++];

  let host = "";
  if (at === AT_IPV4) {
    host = `${u8[idx++]}.${u8[idx++]}.${u8[idx++]}.${u8[idx++]}`;
  } else if (at === AT_DOMAIN) {
    const len = u8[idx++];
    host = td.decode(buf.slice(idx, idx + len));
    idx += len;
  } else if (at === AT_IPV6) {
    const dv = new DataView(buf, idx, 16);
    const parts = [];
    for (let i = 0; i < 8; i++) parts.push(dv.getUint16(i * 2).toString(16));
    host = parts.join(":");
    idx += 16;
  } else {
    return { err: "bad addr type" };
  }

  if (!host) return { err: "empty host" };
  return { ver, isUDP, port, host, dataIndex: idx };
}

function makeReadableStream(ws, earlyDataHeader) {
  let cancelled = false;

  return new ReadableStream({
    start(controller) {
      ws.addEventListener("message", (e) => !cancelled && controller.enqueue(e.data));
      ws.addEventListener("close", () => {
        if (cancelled) return;
        closeQuiet(ws);
        controller.close();
      });
      ws.addEventListener("error", (e) => controller.error(e));

      const early = base64ToArrayBuffer(earlyDataHeader);
      if (early) controller.enqueue(early);
    },
    cancel() {
      cancelled = true;
      closeQuiet(ws);
    },
  });
}

function base64ToArrayBuffer(s) {
  if (!s) return null;
  try {
    s = s.replace(/-/g, "+").replace(/_/g, "/");
    const bin = atob(s);
    const u8 = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
    return u8.buffer;
  } catch {
    return null;
  }
}

function concatU8(headerU8, chunk) {
  const b = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : new Uint8Array(chunk);
  const out = new Uint8Array(headerU8.length + b.length);
  out.set(headerU8, 0);
  out.set(b, headerU8.length);
  return out.buffer;
}

function closeQuiet(ws) {
  try {
    if (ws.readyState === 1 || ws.readyState === 2) ws.close();
  } catch {}
}

const HEX = Array.from({ length: 256 }, (_, i) => (i + 256).toString(16).slice(1));
function bytesToUuid(arr, o) {
  return (
    HEX[arr[o]] +
    HEX[arr[o + 1]] +
    HEX[arr[o + 2]] +
    HEX[arr[o + 3]] +
    "-" +
    HEX[arr[o + 4]] +
    HEX[arr[o + 5]] +
    "-" +
    HEX[arr[o + 6]] +
    HEX[arr[o + 7]] +
    "-" +
    HEX[arr[o + 8]] +
    HEX[arr[o + 9]] +
    "-" +
    HEX[arr[o + 10]] +
    HEX[arr[o + 11]] +
    HEX[arr[o + 12]] +
    HEX[arr[o + 13]] +
    HEX[arr[o + 14]] +
    HEX[arr[o + 15]]
  );
}
